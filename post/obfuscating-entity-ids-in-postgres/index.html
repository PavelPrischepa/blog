<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Obfuscating entity IDs in Postgres - Pavel Prischepa</title><meta name=description content><link rel=icon type=image/x-icon href=https://pavel.prischepa.me/favicon.ico><link rel=apple-touch-icon-precomposed href=https://pavel.prischepa.me/favicon.png><link rel=stylesheet href="https://pavel.prischepa.me/css/style.css?rnd=1592060628"><meta property="og:title" content="Obfuscating entity IDs in Postgres"><meta property="og:description" content="I was looking for a way of obfuscation entity IDs stored in Postgres and make it non-obvious for end users.
Eventually, I found a very interesting approach described in &ldquo;Sharding & IDs at Instagram&rdquo; post. That approach based on generating obfuscated integer identifiers by a timestamp using Postgres function. Generated identifiers could be sorted naturally from oldest to newest, and vice versa.
That article is very interesting though it contains some minor problems that may make it difficult to understand it for beginners."><meta property="og:type" content="article"><meta property="og:url" content="https://pavel.prischepa.me/post/obfuscating-entity-ids-in-postgres/"><meta property="article:published_time" content="2020-06-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-06-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Obfuscating entity IDs in Postgres"><meta name=twitter:description content="I was looking for a way of obfuscation entity IDs stored in Postgres and make it non-obvious for end users.
Eventually, I found a very interesting approach described in &ldquo;Sharding & IDs at Instagram&rdquo; post. That approach based on generating obfuscated integer identifiers by a timestamp using Postgres function. Generated identifiers could be sorted naturally from oldest to newest, and vice versa.
That article is very interesting though it contains some minor problems that may make it difficult to understand it for beginners."><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-23656190-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><a class=skip-main href=#main>Skip to main content</a><div class=container><header><h1 class=site-header><a href=/>Pavel Prischepa</a></h1><nav><a href=https://pavel.prischepa.me/about/>About</a>
<a href=https://pavel.prischepa.me/tags/>Tags</a>
<a href=https://pavel.prischepa.me/posts/>Archive</a></nav></header><main id=main tabindex=-1><article class=post><header><h1>Obfuscating entity IDs in Postgres</h1></header><div class=content><p>I was looking for a way of obfuscation entity IDs stored in Postgres and make it non-obvious for end users.</p><p>Eventually, I found a very interesting approach described in <a href=https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c>&ldquo;Sharding & IDs at Instagram&rdquo;</a> post.
That approach based on generating obfuscated integer identifiers by a timestamp using Postgres function.
Generated identifiers could be sorted naturally from oldest to newest, and vice versa.</p><p>That article is very interesting though it contains some minor problems that may make it difficult to understand it for beginners.</p><p>Here is my implementation of that approach.</p><h2 id=creating-next_id-function>Creating <code>next_id()</code> function</h2><p>Let is use the same Postgres function <code>next_id()</code> for all the tables:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-postgresql data-lang=postgresql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>FUNCTION</span> next_id(sequence_name TEXT, <span style=color:#66d9ef>OUT</span> result BIGINT) <span style=color:#66d9ef>AS</span>
<span style=color:#e6db74>$$</span>
<span style=color:#66d9ef>DECLARE</span>
	app_epoch_millis  BIGINT <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1577836800000</span>; <span style=color:#75715e>-- 2020-01-01 00:00:00
</span><span style=color:#75715e></span>	seq_id     BIGINT;
	now_millis BIGINT;
<span style=color:#66d9ef>BEGIN</span>
	<span style=color:#66d9ef>SELECT</span> (nextval(sequence_name) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>1024</span> <span style=color:#66d9ef>INTO</span> seq_id; <span style=color:#75715e>-- 1024 IDs per millisecond possible
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>SELECT</span> FLOOR(<span style=color:#66d9ef>EXTRACT</span>(EPOCH <span style=color:#66d9ef>FROM</span> clock_timestamp()) <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>) <span style=color:#66d9ef>INTO</span> now_millis;
	<span style=color:#75715e>-- 10 bits for ID
</span><span style=color:#75715e></span>	result <span style=color:#f92672>:=</span> ((now_millis <span style=color:#f92672>-</span> app_epoch_millis) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>10</span>) <span style=color:#f92672>|</span> (seq_id);
<span style=color:#66d9ef>END</span>;
<span style=color:#e6db74>$$</span> <span style=color:#66d9ef>LANGUAGE</span> <span style=color:#e6db74>plpgsql</span>;
</code></pre></div><p>This function generates IDs using sequence name and current timestamp.</p><p>I use <code>BIGINT</code> field type for <code>id</code> fields in database tables.
<code>BIGINT</code> is signed types of 64 bits (Postgres does not support unsigned <code>BIGINT</code>).
As it is signed type, and I want positive values for IDs, I may use <code>64 - 1 = 63 bits</code> only.</p><p>Using this function I can generate up to 1024 ID per millisecond that is pretty enough.
Storing up to 1024 IDs requires <code>10 bits</code>.</p><p>So 63 - 10 = 53 bits left for a timestamp.</p><h3 id=how-long-can-i-generate-ids-this-way-before-overflows-53-bits>How long can I generate IDs this way before overflows 53 bits?</h3><p>Let is calculate. 53 bits can hold:</p><ul><li><code>(1&lt;&lt;53 - 1) = 9007199254740991 milliseconds</code></li><li>or <code>(1&lt;&lt;53 - 1) / 1000 = 9007199254740 seconds</code></li><li>or <code>(1&lt;&lt;53 - 1) / 1000 / 86400 = 104249991 days</code></li><li>or <code>(1&lt;&lt;53 - 1) / 1000 / 86400 / 365 = 285616 years</code></li></ul><p>Yeah, <code>285616 years</code> is pretty enough!</p><p>In other words, I may generate 1024000 IDs per second per table for 285616 years.</p><p>Looks pretty enough for me.</p><h2 id=creating-tables>Creating tables</h2><p>Let is create tables that will use <code>next_id()</code> function.</p><p>Authors table:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-postgresql data-lang=postgresql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>SEQUENCE</span> author_id_seq <span style=color:#66d9ef>AS</span> BIGINT;
<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> book
(
    id            		BIGINT       <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>DEFAULT</span> next_id(<span style=color:#e6db74>&#39;author_id_seq&#39;</span>),
    <span style=color:#66d9ef>Name</span>    			TEXT         <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
);
</code></pre></div><p>Books table:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-postgresql data-lang=postgresql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>SEQUENCE</span> book_id_seq <span style=color:#66d9ef>AS</span> BIGINT;
<span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> book
(
    id            		BIGINT       <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>DEFAULT</span> next_id(<span style=color:#e6db74>&#39;book_id_seq&#39;</span>),
    title    			TEXT         <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
    author_id          	BIGINT       <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
);
</code></pre></div><p>As you may see each table requires its own sequence. The name of the sequence passed as an argument to <code>next_id()</code> function.</p><p><strong>Do not reuse the same sequence in other tables!</strong></p><p>It is so easy to copy/paste a table creation snippet without changing a sequence name that passed to <code>next_id()</code> function and hard to fix such a mistake in a live environment when lots of IDs will be created.</p><h2 id=other-databases>Other databases</h2><p>This approach could be used in MySQL too and other databases that allow creating stored functions or procedures.</p></div><div class=article-info><div class=article-date>2020-06-13</div><div class=article-taxonomies><ul class=article-categories><li><a href=https://pavel.prischepa.me/categories/development>development</a></li></ul><ul class=article-tags><li><a href=https://pavel.prischepa.me/tags/postgres>#postgres</a></li></ul></div></div></article><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"https-pavel-prischepa-me"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><footer><p>© 2020<br>Powered by <a target=_blank href=https://gohugo.io/>Hugo</a>, theme <a target=_blank href=https://github.com/mitrichius/hugo-theme-anubis>Anubis</a>.</p></footer></div></body></html>